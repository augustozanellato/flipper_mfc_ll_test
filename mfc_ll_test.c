#include <gui/gui.h>
#include <notification/notification.h>
#include <notification/notification_messages.h>
#include <nfc/protocols/nfc_protocol.h>
#include <nfc/protocols/mf_classic/mf_classic.h>
#include <nfc/protocols/mf_classic/mf_classic_poller_ll_sync_api.h>
#include <furi.h>
#include <furi_hal_nfc.h>
#include <nfc/nfc.h>
#include <nfc/nfc_poller.h>

/* generated by fbt from .png files in images folder */
#include <mfc_ll_test_icons.h>

typedef enum {
    AppStateWaiting,
    AppStateTestOk,
    AppStateTestFailed,
} AppState;

typedef struct {
    AppState state;
    Nfc* nfc;
    const char* error;
} AppContext;

const char* TAG = "mfc_ll_test";

static void render_callback(Canvas* const canvas, void* context) {
    AppContext* ctx = context;
    canvas_draw_frame(canvas, 0, 0, 128, 64);

    switch(ctx->state) {
    case AppStateWaiting:
        canvas_set_font(canvas, FontPrimary);
        canvas_draw_str_aligned(canvas, 4, 4, AlignLeft, AlignTop, "Press O to start test");
        break;
    case AppStateTestOk:
        canvas_set_font(canvas, FontPrimary);
        canvas_draw_str_aligned(canvas, 4, 4, AlignLeft, AlignTop, "Test successful!");
        break;
    case AppStateTestFailed:
        canvas_set_font(canvas, FontPrimary);
        canvas_draw_str_aligned(canvas, 4, 4, AlignLeft, AlignTop, "Test failed!");
        canvas_set_font(canvas, FontSecondary);
        canvas_draw_str_aligned(canvas, 4, 16, AlignLeft, AlignTop, ctx->error);
        break;
    }
}

static void input_callback(InputEvent* input_event, FuriMessageQueue* event_queue) {
    furi_assert(event_queue);

    furi_message_queue_put(event_queue, input_event, FuriWaitForever);
}

static void log_block(int num, MfClassicBlock* block) {
    FURI_LOG_I(
        TAG,
        "read block %d: %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X",
        num,
        block->data[0],
        block->data[1],
        block->data[2],
        block->data[3],
        block->data[4],
        block->data[5],
        block->data[6],
        block->data[7],
        block->data[8],
        block->data[9],
        block->data[10],
        block->data[11],
        block->data[12],
        block->data[13],
        block->data[14],
        block->data[15]);
}

static bool
    test_auth(MfClassicPollerLl* ll_poller, uint8_t block, MfClassicKeyType key, bool is_nested) {
    uint8_t key_type_nibble = key == MfClassicKeyTypeA ? 0xA0 : 0xB0;
    uint8_t sector_nibble = block >> 2;
    uint8_t key_byte = key_type_nibble | sector_nibble;
    MfClassicKey key0B = {.data = {key_byte, key_byte, key_byte, key_byte, key_byte, key_byte}};
    if(mf_classic_poller_ll_auth(ll_poller, block, &key0B, key, is_nested)) {
        FURI_LOG_E(
            TAG,
            "%s auth-%s(%d) failed with key %02X*6",
            is_nested ? "nested" : "plain",
            key == MfClassicKeyTypeA ? "a" : "b",
            block,
            key_byte);
        return false;
    }
    FURI_LOG_I(
        TAG,
        "%s auth-%s(%d) success with key %02X*6",
        is_nested ? "nested" : "plain",
        key == MfClassicKeyTypeA ? "a" : "b",
        block,
        key_byte);
    return true;
}

static bool nested_auth_loop(MfClassicPollerLl* ll_poller) {
    for(uint8_t i = 0; i < 16; i++) {
        uint8_t block = i << 2;
        if(!test_auth(ll_poller, block, MfClassicKeyTypeA, true)) {
            return false;
        }
        if(!test_auth(ll_poller, block, MfClassicKeyTypeB, true)) {
            return false;
        }
    }
    return true;
}

static bool dump_sector(MfClassicPollerLl* ll_poller, uint8_t sector) {
    MfClassicBlock block;
    uint8_t block_start = sector << 2;
    for(uint8_t i = block_start; i < block_start + 4; i++) {
        if(mf_classic_poller_ll_read_block(ll_poller, i, &block) != MfClassicErrorNone) {
            FURI_LOG_E(TAG, "read(%d) failed", i);
            return false;
        }
        log_block(i, &block);
    }
    return true;
}

static bool valueblock_test(MfClassicPollerLl* ll_poller) {
    if(!test_auth(ll_poller, 8, MfClassicKeyTypeA, true)) {
        return false;
    }
    if(!mf_classic_poller_ll_value_block_command(ll_poller, 8, MF_CLASSIC_CMD_VALUE_INC, 5)) {
        FURI_LOG_E(TAG, "block 8 +5 failed");
        return false;
    }
    if(!mf_classic_poller_ll_value_block_transfer(ll_poller, 8)) {
        FURI_LOG_E(TAG, "block 8 +5 transfer failed");
        return false;
    }
    if(!mf_classic_poller_ll_value_block_command(ll_poller, 8, MF_CLASSIC_CMD_VALUE_DEC, 5)) {
        FURI_LOG_E(TAG, "block 8 -5 failed");
        return false;
    }
    if(!mf_classic_poller_ll_value_block_transfer(ll_poller, 8)) {
        FURI_LOG_E(TAG, "block 8 -5 transfer failed");
        return false;
    }
    return true;
}

static bool test_stuff(AppContext* ctx) {
    MfClassicPollerLl* ll_poller = mf_classic_poller_ll_alloc(ctx->nfc);

    bool res = false;
    do {
        if(!test_auth(ll_poller, 0, MfClassicKeyTypeB, false)) {
            break;
        }
        if(!dump_sector(ll_poller, 0)) {
            break;
        }
        if(!test_auth(ll_poller, 4, MfClassicKeyTypeB, true)) {
            break;
        }
        if(!dump_sector(ll_poller, 1)) {
            break;
        }
        if(!nested_auth_loop(ll_poller)) {
            break;
        }
        if(!valueblock_test(ll_poller)) {
            break;
        }
        res = true;
    } while(false);
    mf_classic_poller_ll_halt(ll_poller);
    mf_classic_poller_ll_free(ll_poller);
    return res;
}

int32_t mfc_ll_test_app(void* p) {
    UNUSED(p);

    FURI_LOG_I(TAG, "Hello world");
    FURI_LOG_I(TAG, "I'm mfc_ll_test!");

    AppContext ctx = {
        .state = AppStateWaiting,
        .nfc = nfc_alloc(),
    };

    NotificationApp* notifications = furi_record_open(RECORD_NOTIFICATION);
    Gui* gui = furi_record_open(RECORD_GUI);
    FuriMessageQueue* event_queue = furi_message_queue_alloc(8, sizeof(InputEvent));
    ViewPort* view_port = view_port_alloc();
    view_port_draw_callback_set(view_port, render_callback, &ctx);
    view_port_input_callback_set(view_port, input_callback, event_queue);
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);

    for(bool processing = true; processing;) {
        InputEvent input_event;
        FuriStatus event_status = furi_message_queue_get(event_queue, &input_event, 100);
        if(event_status == FuriStatusOk && input_event.type == InputTypeShort) {
            if(input_event.key == InputKeyBack) {
                processing = false;
            } else {
                switch(ctx.state) {
                case AppStateWaiting:
                    if(input_event.key == InputKeyOk) {
                        notification_message(notifications, &sequence_blink_start_cyan);
                        bool test_ok = test_stuff(&ctx);
                        ctx.state = test_ok ? AppStateTestOk : AppStateTestFailed;

                        notification_message(notifications, &sequence_blink_stop);
                        notification_message(
                            notifications, test_ok ? &sequence_success : &sequence_error);
                    }
                    break;
                case AppStateTestOk:
                case AppStateTestFailed:
                    ctx.state = AppStateWaiting;
                    break;
                }
            }
        }
        view_port_update(view_port);
    }
    nfc_free(ctx.nfc);
    view_port_enabled_set(view_port, false);
    gui_remove_view_port(gui, view_port);
    view_port_free(view_port);
    furi_message_queue_free(event_queue);

    furi_record_close(RECORD_NOTIFICATION);
    furi_record_close(RECORD_GUI);

    return 0;
}
